module Content
  class GenerateArticle < ApplicationAction
    # Pull Request情報から技術記事を生成する
    # Anthropic Claude Sonnet 4.5 を使用

    SYSTEM_PROMPT = <<~PROMPT
      # Role
      あなたは「DiffDaily」の専属ライターです。熟練したインフラエンジニアとして、OSSの変更内容を技術者向けに深く、かつ簡潔に解説します。

      # Goal
      入力されたGitHubの「Pull Request情報」と「Diff（差分）」をもとに、その変更の要点をまとめた日本語の記事を作成してください。

      # Guidelines (DiffDaily Style)
      1. **Title**: 「[Repo名] 変更内容の要約」という形式。
      2. **Context**: なぜその変更が必要だったのか（解決された課題）を、PRのDescriptionから読み取って冒頭で解説する。
      3. **Technical Detail**: 具体的にコードや設定がどう変わったか、技術的な視点で解説する。「こう書けるようになった」というExampleコードがあれば提示する。
      4. **Target Audience**: 専門知識を持つエンジニア向け。事実とコードを中心に構成する。
      5. **Filtering**: 以下の場合は記事を作成せず、ただ "SKIP" とだけ出力すること。
          - 単なるライブラリのバージョンアップ（Dependabotなど）
          - READMEやドキュメントのみの修正
          - CI（GitHub Actions）の設定変更のみ

      # Custom Markdown Syntax
      DiffDaily はカスタムMarkdown構文をサポートしています。記事作成時に以下の構文を活用してください。

      ## シンタックスハイライト（ファイル名付き）
      コードブロックにファイル名を指定できます。コロンに続けてファイルパスを記述してください。

      ````markdown
      ```ruby:app/models/post.rb
      class Post < ApplicationRecord
        belongs_to :repository
      end
      ```
      ````

      レンダリング時にはファイル名が表示され、コピーボタンが自動的に追加されます。

      ## Mermaid図表
      フローチャート、シーケンス図などを描画できます。複雑な処理フローやアーキテクチャの説明に活用してください。

      ````markdown
      ```mermaid
      graph TD;
          A[開始] --> B[処理]
          B --> C{判定}
          C -->|Yes| D[成功]
          C -->|No| E[失敗]
      ```
      ````

      ## 拡張画像表示
      画像に幅指定やキャプションを追加できます。

      ```markdown
      ![代替テキスト](画像ファイルパス =300px)
      *図1: システムアーキテクチャ*
      ```

      幅指定は `=300px` のように記述し、キャプションは画像の直後の行に `*` で囲んで記述します。

      ## GitHubリンク記法
      記事内でコミットID、プルリクエスト、イシューに言及する際は、以下の形式でリンクを作成してください。

      ### コミットリンク
      コミットIDは短縮形（先頭7文字）を使用し、完全なコミットURLへのリンクを設定します。

      ```markdown
      [2dc080f](https://github.com/rails/rails/commit/2dc080f2b4c49b00d773493975686d5762828c6f)
      ```

      ### プルリクエストリンク
      PR番号には `#` を付けてリンクを設定します。

      ```markdown
      [#1234](https://github.com/rails/rails/pull/1234)
      ```

      ### イシューリンク
      Issue番号には `#` を付けてリンクを設定します。

      ```markdown
      [#5678](https://github.com/rails/rails/issues/5678)
      ```

      重要: リポジトリのベースURLは、この記事の対象となっているリポジトリのURLを使用してください。
      別のリポジトリのコミットやPR、Issueに言及する場合は、そのリポジトリの完全なURLを使用してください。

      # Output Format (JSON)
      記事と要約を以下のJSON形式で出力してください。
      コードブロック（```json）で囲まず、JSON形式のみを出力してください。

      {
        "article": "# タイトル\\n\\n本文...\\n\\n---\\n* **Primary Source**: [PR #<PR_NUMBER>](<PR_URL>)\\n* **Generated by**: <MODEL_NAME> for DiffDaily",
        "summary": "1～3行程度の要約文。記事の要点を簡潔にまとめたもの。"
      }

      重要な注意事項:
      - JSON形式のみを出力し、```json や ``` などのマークダウンコードブロック記法は使用しないこと
      - `article`: Markdown形式の記事本文。末尾には必ずメタデータブロックを含めること。
      - `summary`: 記事の要約（1～3行、プレーンテキスト）。一覧ページで表示される。
      - articleフィールド内の改行は \\n でエスケープすること

      SKIPする場合は、JSONではなく "SKIP" とだけ出力してください。
    PROMPT

    REVIEW_PROMPT = <<~PROMPT
    # Role
    あなたは「DiffDaily」の品質管理担当者です。生成された記事を精査し、以下の観点で評価してください。

    # 精査の観点

    ## 1. ガイドライン準拠
    - **記事構成**: Title、Context、Technical Detailが適切に含まれているか
    - **DiffDaily Style**: システムプロンプトで定義されたスタイルガイドに準拠しているか
    - **カスタムMarkdown**: シンタックスハイライト、Mermaid図表などが適切に使用されているか
    - **対象読者**: 専門知識を持つエンジニア向けの内容になっているか

    ## 2. 技術的整合性
    - **技術用語**: 正確で適切な技術用語が使用されているか
    - **コード例**: コード引用が正しく、実際のDiffと矛盾していないか
    - **説明の正確性**: 技術的な説明に誤りや不正確な表現がないか

    ## 3. PR内容との整合性
    - **タイトル・説明**: PRのタイトルや説明と記事内容が一致しているか
    - **Diff反映**: 実際の差分内容を正確に反映しているか
    - **推測の排除**: 根拠のない推測や誤った解釈がないか

    # Output Format (JSON)
    精査結果を以下のJSON形式で出力してください。
    コードブロック（```json）で囲まず、JSON形式のみを出力してください。

    {
      "approved": true/false,
      "issues": [
        {
          "category": "guideline" | "technical" | "pr_consistency",
          "severity": "critical" | "warning",
          "description": "問題の具体的な説明",
          "suggestion": "修正提案"
        }
      ],
      "overall_feedback": "総合的なフィードバック（承認の場合は空文字列でも可）"
    }

    重要な注意事項:
    - JSON形式のみを出力し、```json や ``` などのマークダウンコードブロック記法は使用しないこと
    - approved: 記事が承認できる品質の場合はtrue、修正が必要な場合はfalse
    - issues: 問題が見つかった場合のみ配列に追加（承認の場合は空配列）
    - severity: critical（修正必須）、warning（推奨改善）
  PROMPT

  MODEL_NAME = "Claude Sonnet 4.5"
  MAX_RETRY_COUNT = 2

    attr_reader :model_name

    def initialize(repository_name, pr_data, repository_url: nil)
      @repository_name = repository_name
      @pr_data = pr_data
      @repository_url = repository_url
      @client = Anthropic::Client.new(api_key: ENV["ANTHROPIC_API_KEY"])
      @model_name = MODEL_NAME
    end

    def perform
      retry_count = 0
      article_result = nil
      previous_feedback = nil
      final_review_result = nil

      loop do
        # 記事生成
        user_prompt = build_user_prompt(previous_feedback)
        system_prompt = build_system_prompt
        response = generate_content(system_prompt, user_prompt)

        # SKIPの場合はnilを返す
        return nil if response.strip == "SKIP"

        # JSON形式のレスポンスをパース
        article_result = parse_response(response)

        # 記事精査
        review_result = review_article(article_result)
        final_review_result = review_result

        # 承認された場合は記事を返却
        if review_result[:approved]
          Rails.logger.info("Article approved after #{retry_count} retries")
          return build_result(article_result, retry_count, review_result, approved: true)
        end

        # リトライ上限に達した場合
        if retry_count >= MAX_RETRY_COUNT
          Rails.logger.warn("Article review failed after #{MAX_RETRY_COUNT} retries")
          Rails.logger.warn("Issues: #{review_result[:issues].inspect}")
          # リトライ上限に達したが、記事は返却する（品質が完璧ではないが公開可能）
          return build_result(article_result, retry_count, review_result, approved: false)
        end

        # リトライ処理
        retry_count += 1
        Rails.logger.info("Article review failed (attempt #{retry_count}/#{MAX_RETRY_COUNT})")
        Rails.logger.info("Issues: #{review_result[:issues].map { |i| i[:description] }.join(', ')}")

        # 次のループで修正指示を反映
        previous_feedback = format_feedback(review_result)
      end
    end

    private

    # GitHubリンクを生成するヘルパーメソッド群
    def github_repo_base_url
      return nil unless @repository_url

      # https://github.com/owner/repo 形式から base URL を抽出
      @repository_url.sub(/\.git$/, "").sub(/\/$/, "")
    end

    def format_commit_link(commit_sha)
      return commit_sha unless github_repo_base_url

      short_sha = commit_sha[0..6]
      "[#{short_sha}](#{github_repo_base_url}/commit/#{commit_sha})"
    end

    def format_pr_link(pr_number)
      return "##{pr_number}" unless github_repo_base_url

      "[##{pr_number}](#{github_repo_base_url}/pull/#{pr_number})"
    end

    def format_issue_link(issue_number)
      return "##{issue_number}" unless github_repo_base_url

      "[##{issue_number}](#{github_repo_base_url}/issues/#{issue_number})"
    end

    def build_system_prompt
      SYSTEM_PROMPT
        .gsub("<PR_NUMBER>", @pr_data[:number].to_s)
        .gsub("<PR_URL>", @pr_data[:url].to_s)
        .gsub("<MODEL_NAME>", @model_name)
    end

    def build_user_prompt(previous_feedback = nil)
      base_prompt = <<~PROMPT
        # Repository
        #{@repository_name}
        #{@repository_url ? "**Repository URL**: #{@repository_url}" : ""}

        # Pull Request Information
        **Title**: #{@pr_data[:title]}
        **URL**: #{@pr_data[:url]}
        **Number**: ##{@pr_data[:number]}
        #{@pr_data[:merge_commit_sha] ? "**Merge Commit**: #{@pr_data[:merge_commit_sha]}" : ""}

        ## Description
        #{@pr_data[:body] || "No description provided."}

        ## Diff Summary
        #{build_diff_summary(@pr_data[:diff])}
      PROMPT

      if previous_feedback
        base_prompt + <<~FEEDBACK

          # 前回の精査結果と修正指示
          #{previous_feedback}

          上記の修正指示を踏まえて、記事を再度作成してください。
        FEEDBACK
      else
        base_prompt + "\n上記の情報をもとに、技術記事を作成してください。"
      end
    end

    def build_diff_summary(diff_files)
      return "No changes" if diff_files.empty?

      summary = diff_files.map do |file|
        <<~FILE
          ### #{file[:filename]} (#{file[:status]})
          - Additions: #{file[:additions]}
          - Deletions: #{file[:deletions]}

          ```diff
          #{file[:patch]&.lines&.first(50)&.join || "No patch available"}
          ```
        FILE
      end

      summary.join("\n")
    end

    def generate_content(system_prompt, user_prompt)
      response = @client.messages.create(
        model: "claude-sonnet-4-5-20250929",
        system_: system_prompt,
        messages: [
          { role: "user", content: user_prompt }
        ],
        max_tokens: 4096
      )

      response.content[0].text
    end

    def review_article(article_result)
      # 記事精査用のプロンプトを構築
      review_user_prompt = build_review_prompt(article_result)

      # AI APIで精査を実行
      response = @client.messages.create(
        model: "claude-sonnet-4-5-20250929",
        system_: REVIEW_PROMPT,
        messages: [
          { role: "user", content: review_user_prompt }
        ],
        max_tokens: 2048
      )

      # レスポンスをパース
      parse_review_response(response.content[0].text)
    rescue StandardError => e
      Rails.logger.error("Article review failed: #{e.message}")
      # エラー時は承認として扱う（精査機能の障害で記事生成を止めない）
      { approved: true, issues: [], overall_feedback: "Review error occurred" }
    end

    def build_review_prompt(article_result)
      <<~PROMPT
        # 生成された記事

        ## 記事本文
        ```markdown
        #{article_result[:article]}
        ```

        ## 元のPR情報（参考）
        **Repository**: #{@repository_name}
        **Title**: #{@pr_data[:title]}
        **URL**: #{@pr_data[:url]}
        **Number**: ##{@pr_data[:number]}

        ## システムプロンプト（記事生成時に使用）
        ```
        #{SYSTEM_PROMPT}
        ```

        上記の情報を基に、生成された記事を精査してください。
      PROMPT
    end

    def parse_review_response(response)
      json_text = response.strip

      # コードブロックで囲まれている場合は除去
      if json_text.start_with?("```json") || json_text.start_with?("```")
        json_text = json_text.sub(/\A```(?:json)?\s*\n?/, "").sub(/\n?```\z/, "")
      end

      # JSONをパース
      parsed = JSON.parse(json_text)

      {
        approved: parsed["approved"],
        issues: parsed["issues"] || [],
        overall_feedback: parsed["overall_feedback"] || ""
      }
    rescue JSON::ParserError => e
      Rails.logger.error("Failed to parse review response: #{e.message}")
      Rails.logger.error("Response text (first 500 chars): #{response[0..500]}")
      # パースエラー時は承認として扱う
      { approved: true, issues: [], overall_feedback: "Parse error occurred" }
    end

    def format_feedback(review_result)
      feedback_text = "## 総合フィードバック\n#{review_result[:overall_feedback]}\n\n"

      if review_result[:issues].any?
        feedback_text += "## 指摘事項\n"
        review_result[:issues].each_with_index do |issue, index|
          feedback_text += <<~ISSUE
            ### #{index + 1}. #{issue['category']} (#{issue['severity']})
            **問題**: #{issue['description']}
            **修正提案**: #{issue['suggestion']}

          ISSUE
        end
      end

      feedback_text
    end

    def build_result(article_result, retry_count, review_result, approved:)
      # レビューステータスを決定
      review_status = determine_review_status(retry_count, approved)

      article_result.merge(
        review_status: review_status,
        review_attempts: retry_count + 1, # 初回も1回とカウント
        review_issues: review_result[:issues]
      )
    end

    def determine_review_status(retry_count, approved)
      if retry_count == 0 && approved
        "approved"
      elsif retry_count > 0 && approved
        "approved_with_retry"
      else
        "approved_with_issues"
      end
    end

    def parse_response(response)
      json_text = response.strip

      # コードブロックで囲まれている場合は除去（後方互換性のため）
      if json_text.start_with?("```json") || json_text.start_with?("```")
        # ```json または ``` で始まり ``` で終わるパターンを探す
        json_text = json_text.sub(/\A```(?:json)?\s*\n?/, "").sub(/\n?```\z/, "")
      end

      # JSONをパース
      parsed = JSON.parse(json_text)

      # 正常なレスポンス形式
      if parsed.is_a?(Hash) && parsed.key?("article")
        {
          article: parsed["article"],
          summary: parsed["summary"]
        }
      else
        # 予期しない形式の場合
        Rails.logger.warn("Unexpected JSON structure: #{parsed.inspect}")
        {
          article: response,
          summary: nil
        }
      end
    rescue JSON::ParserError => e
      # JSON形式でない場合は、レスポンス全体を記事として扱う（後方互換性のため）
      Rails.logger.error("Failed to parse JSON response: #{e.message}")
      Rails.logger.error("Response text (first 500 chars): #{response[0..500]}")
      {
        article: response,
        summary: nil
      }
    end
  end
end
