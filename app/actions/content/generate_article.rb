module Content
  class GenerateArticle < ApplicationAction
    # Pull Request情報から技術記事を生成する
    # Anthropic Claude Sonnet 4.5 を使用

    SYSTEM_PROMPT = <<~PROMPT
      # Role
      あなたは「DiffDaily」の専属ライターです。熟練したインフラエンジニアとして、OSSの変更内容を技術者向けに深く、かつ簡潔に解説します。

      # Goal
      入力されたGitHubの「Pull Request情報」と「Diff（差分）」をもとに、その変更の要点をまとめた日本語の記事を作成してください。

      # Guidelines (DiffDaily Style)
      1. **Title**: 「[Repo名] 変更内容の要約」という形式。
      2. **Context**: なぜその変更が必要だったのか（解決された課題）を、PRのDescriptionから読み取って冒頭で解説する。
      3. **Technical Detail**: 具体的にコードや設定がどう変わったか、技術的な視点で解説する。「こう書けるようになった」というExampleコードがあれば提示する。
      4. **Target Audience**: 専門知識を持つエンジニア向け。事実とコードを中心に構成する。
      5. **Filtering**: 以下の場合は記事を作成せず、ただ "SKIP" とだけ出力すること。
          - 単なるライブラリのバージョンアップ（Dependabotなど）
          - READMEやドキュメントのみの修正
          - CI（GitHub Actions）の設定変更のみ

      # Custom Markdown Syntax
      DiffDaily はカスタムMarkdown構文をサポートしています。記事作成時に以下の構文を活用してください。

      ## シンタックスハイライト（ファイル名付き）
      コードブロックにファイル名を指定できます。コロンに続けてファイルパスを記述してください。

      ````markdown
      ```ruby:app/models/post.rb
      class Post < ApplicationRecord
        belongs_to :repository
      end
      ```
      ````

      レンダリング時にはファイル名が表示され、コピーボタンが自動的に追加されます。

      ## Mermaid図表
      フローチャート、シーケンス図などを描画できます。複雑な処理フローやアーキテクチャの説明に活用してください。

      ````markdown
      ```mermaid
      graph TD;
          A[開始] --> B[処理]
          B --> C{判定}
          C -->|Yes| D[成功]
          C -->|No| E[失敗]
      ```
      ````

      ## 拡張画像表示
      画像に幅指定やキャプションを追加できます。

      ```markdown
      ![代替テキスト](画像ファイルパス =300px)
      *図1: システムアーキテクチャ*
      ```

      幅指定は `=300px` のように記述し、キャプションは画像の直後の行に `*` で囲んで記述します。

      ## GitHubリンク記法
      記事内でコミットID、プルリクエスト、イシューに言及する際は、以下の形式でリンクを作成してください。

      ### コミットリンク
      コミットIDは短縮形（先頭7文字）を使用し、完全なコミットURLへのリンクを設定します。

      ```markdown
      [2dc080f](https://github.com/rails/rails/commit/2dc080f2b4c49b00d773493975686d5762828c6f)
      ```

      ### プルリクエストリンク
      PR番号には `#` を付けてリンクを設定します。

      ```markdown
      [#1234](https://github.com/rails/rails/pull/1234)
      ```

      ### イシューリンク
      Issue番号には `#` を付けてリンクを設定します。

      ```markdown
      [#5678](https://github.com/rails/rails/issues/5678)
      ```

      重要: リポジトリのベースURLは、この記事の対象となっているリポジトリのURLを使用してください。
      別のリポジトリのコミットやPR、Issueに言及する場合は、そのリポジトリの完全なURLを使用してください。

      ## コードブロックの前後の空行
      コードブロックの前後には必ず空行を入れてください。見出しや段落とコードブロックが直接隣接しないようにしてください。

      ### 悪い例
      ```markdown
      **変更前:**
      ```ruby:railties/lib/rails/application/finisher.rb
      initializer :enable_yjit do
        if config.yjit && defined?(RubyVM::YJIT.enable)
          options = config.yjit.is_a?(Hash) ? config.yjit : {}
          RubyVM::YJIT.enable(**options)
        end
      end
      ```
      ```

      ### 良い例
      ```markdown
      **変更前:**

      ```ruby:railties/lib/rails/application/finisher.rb
      initializer :enable_yjit do
        if config.yjit && defined?(RubyVM::YJIT.enable)
          options = config.yjit.is_a?(Hash) ? config.yjit : {}
          RubyVM::YJIT.enable(**options)
        end
      end
      ```
      ```

      # Output Format (JSON)
      記事と要約を以下のJSON形式で出力してください。
      コードブロック（```json）で囲まず、JSON形式のみを出力してください。

      {
        "article": "# タイトル\\n\\n本文...\\n\\n---\\n* **Primary Source**: [PR #<PR_NUMBER>](<PR_URL>)\\n* **Generated by**: <MODEL_NAME> for DiffDaily",
        "summary": "1～3行程度の要約文。記事の要点を簡潔にまとめたもの。"
      }

      重要な注意事項:
      - JSON形式のみを出力し、```json や ``` などのマークダウンコードブロック記法は使用しないこと
      - `article`: Markdown形式の記事本文。末尾には必ずメタデータブロックを含めること。
      - `summary`: 記事の要約（1～3行、プレーンテキスト）。一覧ページで表示される。
      - articleフィールド内の改行は \\n でエスケープすること

      SKIPする場合は、JSONではなく "SKIP" とだけ出力してください。
    PROMPT

    REVIEW_PROMPT = <<~PROMPT
    # Role
    あなたは「DiffDaily」の品質管理担当者です。生成された記事を精査し、以下の観点で評価してください。

    # 精査の観点

    ## 1. ガイドライン準拠
    以下の項目を確認してください：

    ### 記事構成（必須要素）
    - **Title**: 「[Repo名] 変更内容の要約」形式であること
    - **Context**: 変更の背景・解決された課題が冒頭で説明されていること
    - **Technical Detail**: 具体的なコード変更が技術的視点で解説されていること

    **判定基準**:
    - FAIL: 上記3要素のいずれかが欠落している
    - WARNING: 3要素はあるが、説明が不十分または曖昧
    - PASS: 3要素すべてが明確に記載されている

    ### カスタムMarkdown構文
    以下の項目を確認してください：

    1. **コードブロック前後の空行**（重要）:
       - コードブロックの直前と直後に必ず空行があること
       - 見出し（**変更前:** など）とコードブロックが直接隣接していないこと

    2. **ファイル名付きシンタックスハイライト**:
       - コードブロックにファイル名が指定されている場合、形式が正しいこと（```言語:ファイルパス）

    3. **GitHubリンク記法**:
       - コミットIDは短縮形（7文字）でリンク化されていること: [abc1234](完全なURL)
       - PR番号は #付きでリンク化されていること: [#123](完全なURL)
       - Issue番号も同様: [#456](完全なURL)

    **判定基準**:
    - FAIL: コードブロック前後の空行が欠落している（可読性に重大な影響）
    - WARNING: GitHubリンク記法が不完全だが、内容理解には影響しない
    - PASS: すべての構文が正しく使用されている

    ### 対象読者への適合性
    - 専門知識を持つエンジニア向けの内容であること
    - 過度な説明や初心者向けの解説がないこと

    **判定基準**:
    - FAIL: 技術レベルが対象読者と大きく乖離している
    - WARNING: 一部に不要な説明があるが、全体としては適切
    - PASS: 対象読者に適した技術レベルと表現

    ## 2. 技術的整合性
    以下の手順で検証してください：

    ### ステップ1: Diff内容との照合
    1. 記事内のコードブロックを抽出
    2. 提供されたDiff内の実際のコードと比較
    3. 以下を確認：
       - コード引用がDiffに存在するか
       - コードの改変や省略がないか
       - ファイル名がDiffのfilenameと一致するか

    **判定基準**:
    - FAIL: Diffに存在しないコードを引用している、またはコードを改変している
    - WARNING: Diffの一部を省略しているが、技術的な理解を妨げない
    - PASS: Diff内容を正確に反映している

    ### ステップ2: 技術用語の正確性
    1. 記事内の技術用語を抽出
    2. 提供されたPR情報（Title、Description）内の用語と照合
    3. 以下を確認：
       - PR情報内の用語と一致しているか
       - 一般的な技術用語の誤用がないか
       - 文脈に適した用語選択か

    **判定基準**:
    - FAIL: 明らかな技術用語の誤用がある
    - WARNING: 用語選択が最適ではないが、理解を妨げない
    - PASS: 正確で適切な技術用語を使用

    ### ステップ3: 説明の技術的正確性
    1. 記事内の技術的主張を抽出
    2. PR情報とDiffで裏付けられるか確認
    3. 以下を確認：
       - 主張に根拠があるか
       - 因果関係が論理的か
       - 技術的に誤った説明がないか

    **判定基準**:
    - FAIL: 技術的に誤った説明がある
    - WARNING: 説明が曖昧だが、誤りではない
    - PASS: 技術的に正確で論理的な説明

    ## 3. PR内容との整合性（ハルシネーション検出）
    以下の手順でハルシネーションを検出してください：

    ### ステップ1: 事実の突合
    1. 記事内の主張・説明をリストアップ
    2. 各主張について、以下のいずれかで裏付けられるか確認：
       - PR Title
       - PR Description
       - Diff内のコード
       - コミットメッセージ（提供されている場合）
    3. 裏付けのない推測や憶測を特定

    **判定基準**:
    - FAIL: PR情報に記載のない重要な主張がある（例: 「パフォーマンスが50%向上」など）
    - WARNING: 妥当な推測だが、PR情報で明示されていない（例: 「起動時間が改善される可能性」）
    - PASS: すべての主張がPR情報で裏付けられている

    ### ステップ2: 数値・固有名詞の確認
    以下の項目が正確か確認：
    - PR番号
    - コミットID（提供されている場合）
    - Issue番号（言及されている場合）
    - バージョン番号
    - 設定値・定数

    **判定基準**:
    - FAIL: 重要な数値や固有名詞が誤っている
    - WARNING: 軽微な表記ゆれがある
    - PASS: すべて正確

    ### ステップ3: タイトル・説明との一致
    - 記事のタイトルがPRの内容を正確に表現しているか
    - 記事の説明がPR Descriptionの内容と矛盾していないか

    **判定基準**:
    - FAIL: PRの内容と記事の主題が一致していない
    - WARNING: 一部に解釈の相違があるが、大筋で一致
    - PASS: PRの内容を正確に表現している

    # 評価例

    ## ガイドライン準拠の例

    ### PASS例
    - コードブロックの前後に空行がある
    - Title、Context、Technical Detailがすべて明確
    - GitHubリンクが正しい形式: [abc1234](https://github.com/org/repo/commit/abc1234...)

    ### WARNING例
    - 記事構成は適切だが、Context の説明がやや簡潔すぎる
    - コミットIDがリンク化されていない（読者は手動でアクセス可能）

    ### FAIL例
    - コードブロックの直前に空行がない（可読性の問題）
    - Context セクションが欠落している

    ## 技術的整合性の例

    ### PASS例
    - 記事: 「`config.yjit` オプションを設定すると YJIT が有効化されます」
    - Diff: `if config.yjit && defined?(RubyVM::YJIT.enable)` のコードが存在
    - 評価: Diffの内容と説明が一致

    ### WARNING例
    - 記事: 「この変更により、YJIT の設定がより柔軟になります」
    - PR: 「Add hash support for yjit config」
    - 評価: 「柔軟」という表現は主観的だが、技術的に誤りではない

    ### FAIL例
    - 記事: 「`RubyVM::YJIT.enable(jit: true)` のように呼び出します」
    - Diff: `RubyVM::YJIT.enable(**options)` のみ
    - 評価: Diffに存在しない具体的な呼び出し例を記載している

    ## PR内容との整合性の例

    ### PASS例
    - 記事: 「[#1234](URL) で報告された問題を修正しました」
    - PR Description: 「Fix issue #1234」
    - 評価: PR情報で裏付けられている

    ### WARNING例
    - 記事: 「この変更により起動時間が改善される可能性があります」
    - PR Description: 「Improve initialization process」
    - 評価: 「起動時間」は推測だが、「improve」から妥当な推測

    ### FAIL例
    - 記事: 「ベンチマークでパフォーマンスが50%向上しました」
    - PR Description: 「Refactor code」
    - 評価: PR情報にベンチマーク結果の記載がなく、根拠のない主張

    # Output Format (JSON)
    精査結果を以下のJSON形式で出力してください。
    コードブロック（```json）で囲まず、JSON形式のみを出力してください。

    {
      "approved": true/false,
      "criteria_evaluation": {
        "guideline": {
          "status": "pass" | "warning" | "fail",
          "feedback": "この観点についての具体的な評価コメント（良い点または問題点）"
        },
        "technical": {
          "status": "pass" | "warning" | "fail",
          "feedback": "この観点についての具体的な評価コメント（Diffとの照合結果を含む）"
        },
        "pr_consistency": {
          "status": "pass" | "warning" | "fail",
          "feedback": "この観点についての具体的な評価コメント（ハルシネーション検出結果を含む）"
        }
      },
      "issues": [
        {
          "category": "guideline" | "technical" | "pr_consistency",
          "severity": "critical" | "warning",
          "description": "問題の具体的な説明（該当箇所を明示）",
          "suggestion": "修正提案（具体的な修正内容）"
        }
      ],
      "overall_feedback": "総合的なフィードバック"
    }

    重要な注意事項:
    - JSON形式のみを出力し、```json や ``` などのマークダウンコードブロック記法は使用しないこと
    - approved: すべての観点が "pass" または "warning" の場合は true、いずれかが "fail" の場合は false
    - criteria_evaluation: 各観点について必ず評価を記載すること
      - status: 上記の判定基準に従って判定
      - feedback: 具体的な評価理由を記載（PASSの場合も良い点を明示）
    - issues: severity="critical" の問題が1つでもあれば approved は false とすること
    - severity: critical（修正必須、approved=false）、warning（推奨改善、approved=true可）
    - overall_feedback: 全体的な評価と総評を必ず記載する
  PROMPT

  MODEL_NAME = "Claude Sonnet 4.5"
  REVIEWER_MODEL_NAME = "Gemini 2.5 Pro"  # 実際のモデル: gemini-2.5-pro
  MAX_RETRY_COUNT = 2
  ENABLE_REVIEW = ENV.fetch("ENABLE_ARTICLE_REVIEW", "true") == "true"

    attr_reader :model_name

    def initialize(repository_name, pr_data, repository_url: nil)
      @repository_name = repository_name
      @pr_data = pr_data
      @repository_url = repository_url
      @merged_at = pr_data[:merged_at] # PRのマージ日時を保存
      @claude_client = Anthropic::Client.new(api_key: ENV["ANTHROPIC_API_KEY"])
      @gemini_client = Gemini.new(
        credentials: {
          service: "generative-language-api",
          api_key: ENV["GEMINI_API_KEY"]
        },
        options: { model: "gemini-2.5-pro", server_sent_events: true }
      )
      @model_name = MODEL_NAME
    end

    def perform
      retry_count = 0
      article_result = nil
      previous_feedback = nil
      final_review_result = nil

      loop do
        # 記事生成
        user_prompt = build_user_prompt(previous_feedback)
        system_prompt = build_system_prompt
        response = generate_content(system_prompt, user_prompt)

        # SKIPの場合はnilを返す
        return nil if response.strip == "SKIP"

        # JSON形式のレスポンスをパース
        article_result = parse_response(response)

        # レビュー機能が無効な場合はレビューをスキップ
        unless ENABLE_REVIEW
          Rails.logger.info("Article review is disabled (ENABLE_ARTICLE_REVIEW=false)")
          review_result = {
            approved: true,
            issues: [],
            overall_feedback: "Review skipped (disabled)",
            raw_response: {},
            reviewer_model: "Review Disabled"
          }
          return build_result(article_result, 0, review_result, approved: true)
        end

        # 記事精査
        review_result = review_article(article_result)
        final_review_result = review_result

        # 承認された場合は記事を返却
        if review_result[:approved]
          Rails.logger.info("Article approved after #{retry_count} retries")
          return build_result(article_result, retry_count, review_result, approved: true)
        end

        # リトライ上限に達した場合
        if retry_count >= MAX_RETRY_COUNT
          Rails.logger.warn("Article review failed after #{MAX_RETRY_COUNT} retries")
          Rails.logger.warn("Issues: #{review_result[:issues].inspect}")
          # リトライ上限に達したが、記事は返却する（品質が完璧ではないが公開可能）
          return build_result(article_result, retry_count, review_result, approved: false)
        end

        # リトライ処理
        retry_count += 1
        Rails.logger.info("Article review failed (attempt #{retry_count}/#{MAX_RETRY_COUNT})")
        Rails.logger.info("Issues: #{review_result[:issues].map { |i| i[:description] }.join(', ')}")

        # 次のループで修正指示を反映
        previous_feedback = format_feedback(review_result)
      end
    end

    private

    # GitHubリンクを生成するヘルパーメソッド群
    def github_repo_base_url
      return nil unless @repository_url

      # https://github.com/owner/repo 形式から base URL を抽出
      @repository_url.sub(/\.git$/, "").sub(/\/$/, "")
    end

    def format_commit_link(commit_sha)
      return commit_sha unless github_repo_base_url

      short_sha = commit_sha[0..6]
      "[#{short_sha}](#{github_repo_base_url}/commit/#{commit_sha})"
    end

    def format_pr_link(pr_number)
      return "##{pr_number}" unless github_repo_base_url

      "[##{pr_number}](#{github_repo_base_url}/pull/#{pr_number})"
    end

    def format_issue_link(issue_number)
      return "##{issue_number}" unless github_repo_base_url

      "[##{issue_number}](#{github_repo_base_url}/issues/#{issue_number})"
    end

    def build_system_prompt
      SYSTEM_PROMPT
        .gsub("<PR_NUMBER>", @pr_data[:number].to_s)
        .gsub("<PR_URL>", @pr_data[:url].to_s)
        .gsub("<MODEL_NAME>", @model_name)
    end

    def build_user_prompt(previous_feedback = nil)
      base_prompt = <<~PROMPT
        # Repository
        #{@repository_name}
        #{@repository_url ? "**Repository URL**: #{@repository_url}" : ""}

        # Pull Request Information
        **Title**: #{@pr_data[:title]}
        **URL**: #{@pr_data[:url]}
        **Number**: ##{@pr_data[:number]}
        #{@pr_data[:merge_commit_sha] ? "**Merge Commit**: #{@pr_data[:merge_commit_sha]}" : ""}

        ## Description
        #{@pr_data[:body] || "No description provided."}

        ## Diff Summary
        #{build_diff_summary(@pr_data[:diff])}
      PROMPT

      if previous_feedback
        base_prompt + <<~FEEDBACK

          # 前回の精査結果と修正指示
          #{previous_feedback}

          上記の修正指示を踏まえて、記事を再度作成してください。
        FEEDBACK
      else
        base_prompt + "\n上記の情報をもとに、技術記事を作成してください。"
      end
    end

    def build_diff_summary(diff_files)
      return "No changes" if diff_files.empty?

      summary = diff_files.map do |file|
        <<~FILE
          ### #{file[:filename]} (#{file[:status]})
          - Additions: #{file[:additions]}
          - Deletions: #{file[:deletions]}

          ```diff
          #{file[:patch]&.lines&.first(50)&.join || "No patch available"}
          ```
        FILE
      end

      summary.join("\n")
    end

    def generate_content(system_prompt, user_prompt)
      response = @claude_client.messages.create(
        model: "claude-sonnet-4-5-20250929",
        system_: system_prompt,
        messages: [
          { role: "user", content: user_prompt }
        ],
        max_tokens: 4096
      )

      response.content[0].text
    end

    def review_article(article_result)
      # 記事精査用のプロンプトを構築
      review_user_prompt = build_review_prompt(article_result)

      # Gemini APIで精査を実行（リトライ付き）
      full_prompt = "#{REVIEW_PROMPT}\n\n#{review_user_prompt}"

      max_api_retries = 3
      retry_count = 0

      begin
        result = @gemini_client.stream_generate_content({
          contents: { role: "user", parts: { text: full_prompt } }
        })

        # レスポンスからテキストを抽出
        response_text = extract_gemini_response_text(result)

        # レスポンスをパース
        parsed_result = parse_review_response(response_text)
        parsed_result[:reviewer_model] = REVIEWER_MODEL_NAME
        parsed_result
      rescue Faraday::TooManyRequestsError => e
        retry_count += 1
        if retry_count < max_api_retries
          wait_time = retry_count * 2 # 2秒、4秒、6秒と待機時間を増やす
          Rails.logger.warn("Gemini API rate limit hit (attempt #{retry_count}/#{max_api_retries}). Retrying in #{wait_time} seconds...")
          sleep(wait_time)
          retry
        else
          Rails.logger.error("Gemini API rate limit exceeded after #{max_api_retries} retries")
          Rails.logger.error(e.backtrace.join("\n"))
          # リトライ上限に達したら承認として扱う
          { approved: true, issues: [], overall_feedback: "Review error: Rate limit exceeded", raw_response: {}, reviewer_model: "Review Error" }
        end
      rescue StandardError => e
        Rails.logger.error("Article review failed: #{e.message}")
        Rails.logger.error(e.backtrace.join("\n"))
        # エラー時は承認として扱う（精査機能の障害で記事生成を止めない）
        { approved: true, issues: [], overall_feedback: "Review error occurred", raw_response: {}, reviewer_model: "Review Error" }
      end
    end

    def build_review_prompt(article_result)
      <<~PROMPT
        # 生成された記事

        ## 記事本文
        ```markdown
        #{article_result[:article]}
        ```

        ## 元のPR情報（参考）
        **Repository**: #{@repository_name}
        **Title**: #{@pr_data[:title]}
        **URL**: #{@pr_data[:url]}
        **Number**: ##{@pr_data[:number]}

        ## システムプロンプト（記事生成時に使用）
        ```
        #{SYSTEM_PROMPT}
        ```

        上記の情報を基に、生成された記事を精査してください。
      PROMPT
    end

    def extract_gemini_response_text(result)
      # Gemini APIのストリーミングレスポンスからテキストを抽出
      text_parts = []

      result.each do |event|
        if event.dig("candidates", 0, "content", "parts")
          event.dig("candidates", 0, "content", "parts").each do |part|
            text_parts << part["text"] if part["text"]
          end
        end
      end

      text_parts.join
    end

    def parse_review_response(response)
      json_text = response.strip

      # コードブロックで囲まれている場合は除去
      if json_text.start_with?("```json") || json_text.start_with?("```")
        json_text = json_text.sub(/\A```(?:json)?\s*\n?/, "").sub(/\n?```\z/, "")
      end

      # JSONをパース
      parsed = JSON.parse(json_text)

      {
        approved: parsed["approved"],
        issues: parsed["issues"] || [],
        overall_feedback: parsed["overall_feedback"] || "",
        raw_response: parsed # 詳細情報を保持
      }
    rescue JSON::ParserError => e
      Rails.logger.error("Failed to parse review response: #{e.message}")
      Rails.logger.error("Response text (first 500 chars): #{response[0..500]}")
      # パースエラー時は承認として扱う
      { approved: true, issues: [], overall_feedback: "Parse error occurred", raw_response: {} }
    end

    def format_feedback(review_result)
      feedback_text = "## 総合フィードバック\n#{review_result[:overall_feedback]}\n\n"

      if review_result[:issues].any?
        feedback_text += "## 指摘事項\n"
        review_result[:issues].each_with_index do |issue, index|
          feedback_text += <<~ISSUE
            ### #{index + 1}. #{issue['category']} (#{issue['severity']})
            **問題**: #{issue['description']}
            **修正提案**: #{issue['suggestion']}

          ISSUE
        end
      end

      feedback_text
    end

    def build_result(article_result, retry_count, review_result, approved:)
      # レビューステータスを決定
      review_status = determine_review_status(retry_count, approved)

      # レビュー観点の詳細情報を構築
      review_details = build_review_details(review_result)

      article_result.merge(
        review_status: review_status,
        review_attempts: retry_count + 1, # 初回も1回とカウント
        review_issues: review_result[:issues],
        reviewer_model: review_result[:reviewer_model],
        review_details: review_details,
        merged_at: @merged_at # PRのマージ日時を追加
      )
    end

    def determine_review_status(retry_count, approved)
      if retry_count == 0 && approved
        "approved"
      elsif retry_count > 0 && approved
        "approved_with_retry"
      else
        "approved_with_issues"
      end
    end

    def build_review_details(review_result)
      # レビュー観点の詳細情報を構築
      criteria_evaluation = review_result.dig(:raw_response, "criteria_evaluation") || {}

      {
        criteria: [
          {
            name: "ガイドライン準拠",
            key: "guideline",
            description: "記事構成とDiffDaily Styleへの準拠状況",
            sub_criteria: [
              "記事構成(Title、Context、Technical Detail)",
              "DiffDaily Styleガイド準拠",
              "カスタムMarkdown活用",
              "対象読者への適合性"
            ],
            status: criteria_evaluation.dig("guideline", "status") || "unknown",
            feedback: criteria_evaluation.dig("guideline", "feedback") || ""
          },
          {
            name: "技術的整合性",
            key: "technical",
            description: "技術的な正確性と表現の適切性",
            sub_criteria: [
              "技術用語の正確性",
              "コード例の正確性",
              "説明の技術的正確性"
            ],
            status: criteria_evaluation.dig("technical", "status") || "unknown",
            feedback: criteria_evaluation.dig("technical", "feedback") || ""
          },
          {
            name: "PR内容との整合性",
            key: "pr_consistency",
            description: "元のPR情報との一致度",
            sub_criteria: [
              "タイトル・説明の一致",
              "Diff内容の正確な反映",
              "推測の排除"
            ],
            status: criteria_evaluation.dig("pr_consistency", "status") || "unknown",
            feedback: criteria_evaluation.dig("pr_consistency", "feedback") || ""
          }
        ],
        evaluation: categorize_issues_by_criteria(review_result[:issues]),
        overall_feedback: review_result[:overall_feedback],
        approved: review_result[:approved]
      }
    end

    def categorize_issues_by_criteria(issues)
      # 観点別に問題を分類
      {
        guideline: issues.select { |i| i["category"] == "guideline" },
        technical: issues.select { |i| i["category"] == "technical" },
        pr_consistency: issues.select { |i| i["category"] == "pr_consistency" }
      }
    end

    def parse_response(response)
      json_text = response.strip

      # コードブロックで囲まれている場合は除去（後方互換性のため）
      if json_text.start_with?("```json") || json_text.start_with?("```")
        # ```json または ``` で始まり ``` で終わるパターンを探す
        json_text = json_text.sub(/\A```(?:json)?\s*\n?/, "").sub(/\n?```\z/, "")
      end

      # JSONをパース
      parsed = JSON.parse(json_text)

      # 正常なレスポンス形式
      if parsed.is_a?(Hash) && parsed.key?("article")
        {
          article: parsed["article"],
          summary: parsed["summary"]
        }
      else
        # 予期しない形式の場合
        Rails.logger.warn("Unexpected JSON structure: #{parsed.inspect}")
        {
          article: response,
          summary: nil
        }
      end
    rescue JSON::ParserError => e
      # JSON形式でない場合は、レスポンス全体を記事として扱う（後方互換性のため）
      Rails.logger.error("Failed to parse JSON response: #{e.message}")
      Rails.logger.error("Response text (first 500 chars): #{response[0..500]}")
      {
        article: response,
        summary: nil
      }
    end
  end
end
